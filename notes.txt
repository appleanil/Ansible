Loops in ansible
=================

In Ansible, loops allow you to iterate over a list of items, making your playbooks more dynamic and reducing repetition.


without lopps
-------------

---
- name: Install packages without loops
  hosts: all
  become: yes
  tasks:
    - name: Install Git
      yum:
        name: git
        state: present

    - name: Install Zip
      yum:
        name: zip
        state: present

    - name: Install Vim
      yum:
        name: vim
        state: present

    - name: install unzip
      yum:
        name: unzip
        state: present


            ------------------------------------------------------------------------------------------------
                    AFTER THIS PLAYBOOK, YOU NEED TO DO THIS AS ABSENT MEANS UNINSTALL THE PACKAGES
            ------------------------------------------------------------------------------------------------



without-loops & debug yaml file
-------------------------------

---
- name: Install packages without loops
  hosts: all
  become: yes

  tasks:
    - name: Debug - Installing Git
      debug:
        msg: "Starting installation of Git"

    - name: Install Git
      yum:
        name: git
        state: present

    - name: Debug - Git installed
      debug:
        msg: "Git installation completed"

    - name: Debug - Installing Zip
      debug:
        msg: "Starting installation of Zip"

    - name: Install Zip
      yum:
        name: zip
        state: present

    - name: Debug - Zip installed
      debug:
        msg: "Zip installation completed"

    - name: Debug - Installing Vim
      debug:
        msg: "Starting installation of Vim"

    - name: Install Vim
      yum:
        name: vim
        state: present

    - name: Debug - Vim installed
      debug:
        msg: "Vim installation completed"

    - name: Debug - Installing Unzip
      debug:
        msg: "Starting installation of Unzip"

    - name: Install Unzip
      yum:
        name: unzip
        state: present

    - name: Debug - Unzip installed
      debug:
        msg: "Unzip installation completed"

                 ------------------------------------------------------------------------------------------------
                           AFTER THIS PLAYBOOK, YOU NEED TO DO THIS AS ABSENT MEANS UNINSTALL THE PACKAGES
                 ------------------------------------------------------------------------------------------------




with-loops
----------
approach 1:

- name: Install packages with loops
  hosts: all
  become: yes
  tasks:
    - name: Install packages
      yum:
        name: "{{ item }}"
        state: present
      loop:
        - git
        - zip
        - vim
        - unzip
        - tree

                             ------------------------------------------------------------------------------------------------
                                     AFTER THIS PLAYBOOK, YOU NEED TO DO THIS AS ABSENT MEANS UNINSTALL THE PACKAGES
                             ------------------------------------------------------------------------------------------------


with-loops & debug yaml file
----------------------------

i want install in redhat only then ask chtght and ask when condition statements also so that we can do more practises

---
- name: Install packages with loops
  hosts: all
  become: yes

  tasks:
    - name: Debug - Starting installation of packages
      debug:
        msg: "Installing package: {{ item }}"
      loop:
        - git
        - zip
        - vim
        - unzip
        - tree

    - name: Install packages
      yum:
        name: "{{ item }}"
        state: present
      loop:
        - git
        - zip
        - vim
        - unzip
        - tree

    - name: Debug - Package installation completed
      debug:
        msg: "Installation completed for package: {{ item }}"
      loop:
        - git
        - zip
        - vim
        - unzip
        - tree

                 ------------------------------------------------------------------------------------------------
                           AFTER THIS PLAYBOOK, YOU NEED TO DO THIS AS ABSENT MEANS UNINSTALL THE PACKAGES
                 ------------------------------------------------------------------------------------------------



 approach 2:
 -----------

---
- name: Install packages with with_items
  hosts: all
  become: yes

  tasks:
    - name: Install packages
      yum:
        name: "{{ item }}"
        state: present
      with_items:
        - git
        - zip
        - vim
        - unzip


                       ------------------------------------------------------------------------------------------------
                               AFTER THIS PLAYBOOK, YOU NEED TO DO THIS AS ABSENT MEANS UNINSTALL THE PACKAGES
                       ------------------------------------------------------------------------------------------------


How to uninstall?
-----------------

- name: Uninstall packages with with_items
  hosts: all
  become: yes
  tasks:
    - name: Uninstall packages
      yum:
        name: "{{ item }}"
        state: absent
      with_items:
        - git
        - zip
        - vim
        - unzip



Assignment 
----------

--> create 5 users in all the machines using loops.

---
- name: Create users on all machines
  hosts: all
  become: yes  # Use 'become' to run commands as a superuser
  vars:
    users:
      - nagaraj
      - santhi
      - usha
      - niranjan
      - sathya

  tasks:
    - name: Ensure users are present
      user:
        name: "{{ item }}"
        state: present
      loop: "{{ users }}"





when condition in ansible
=========================

for practise create three instances like 1. Amazon linux 2. Ubuntu 3. Redhat

ansible all -m ping

paste the IP address in sudo vi /etc/ansible/hosts

we can define like also [webserver] have 2 instances, [db] 3 instances, [frontend] 4 instances

[webservers]
172.31.3.184 ansible_ssh_user=ec2-user ansible_ssh_private_key_file=~/kkdevopsb7.pem
172.31.0.49  ansible_ssh_user=ec2-user ansible_ssh_private_key_file=~/kkdevopsb7.pem
172.31.5.94  ansible_ssh_user=ubuntu   ansible_ssh_private_key_file=~/kkdevopsb7.pem


ansible all -m setup

ansible all -m setup | grep "redhat" "ubuntu" "amazon"

ansible all -m setup | grep "ansible_distribution"

not only we are filtering ansible_distribution there no:of 
1. ansible_distribution
2. ansible_distribution_version
3. ansible_default_ipv4.address
4. ansible_hostname
5. ansible_memtotal_mb
6. ansible_processor_vcpus

plz ask no:of playbooks to do best practises when condition multiple use cases in real time devops engineers

In Ansible, you can use the when condition to control whether a task should be executed based on a specific condition.

NOTE: take one ubuntu machine

---
- name: Install HTTP server conditionally for Ubuntu and Red Hat
  hosts: all #[ubuntu] [amazon] [redhat] [webservers] [db] [frontend] we can mention here
  become: yes
  tasks:
    - name: Install Apache on Ubuntu
      apt:
        name: apache2
        state: present
      when: ansible_distribution == "Ubuntu"

    - name: Install Apache on Red Hat
      yum:
        name: httpd
        state: present
      when: ansible_distribution == "RedHat"

    - name: Start Apache service on Ubuntu
      service:
        name: apache2
        state: started
        enabled: yes
      when: ansible_distribution == "Ubuntu"

    - name: Start Apache service on Red Hat
      service:
        name: httpd
        state: started
        enabled: yes
      when: ansible_distribution == "RedHat"




---
- name: Install HTTP server conditionally for Ubuntu and Red Hat
  hosts: all
  become: yes
  tasks:
    - name: Install Apache on Ubuntu
      apt:
        name: apache2
        state: present
      when: ansible_distribution == "Ubuntu"

    - name: Start Apache service on Ubuntu
      service:
        name: apache2
        state: started
        enabled: yes
      when: ansible_distribution == "Ubuntu"





tags in ansible
===============

In Ansible, a tag is a label that you can assign to tasks, plays, or roles in your playbook. 
Tags allow you to selectively run specific parts of your playbook without executing the entire playbook. 
This can be especially useful for larger playbooks where you may want to test or apply only certain tasks.

before write ansible playbook must and should create index.html insert some data <h1> hi im leaning Devops </h1>
later some changes are happens in index.html <h1> hi im learning Devops,AWS,SRE,Decsecops </h2>
then run this commands 

1. ansible-playbook name.yaml --syntax-check

2. ansible-playbook name.yaml --list-tags

3. ansible-playbook your_playbook.yml --tags "deploy" #install configure start --> to run the playbook

4. ansible-playbook manage_web_server.yml --skip-tags install #start #deploy configure  --> to skip the particular task.


---
- name: Install and configure Apache HTTP server
  hosts: all  
  become: true 

  tasks:
    - name: Install httpd
      yum:  # Use yum for Red Hat/CentOS or dnf for newer versions
        name: httpd
        state: present
      tags: install #start

    - name: Ensure httpd is started and enabled
      service:
        name: httpd
        state: started
        enabled: true
      tags: configure

    - name: Copy custom index.html to the web root
      copy:
        src: index.html  # Path to your local index.html file
        dest: /var/www/html/index.html  # Destination on the target server
      tags: deploy







roles in ansible
================

Roles in Ansible are a way to organize playbooks into reusable components.

Creating a Role
----------------

--> To create a role, you can use the ansible-galaxy command:

ansible-galaxy init httpd



 Directory Structure for the Role

The role will have a similar structure to before but will include a `templates` directory for the `index.html` template file, 
and a `vars` directory for the `vars.yaml` file.


roles/
â”œâ”€â”€ apache
â”‚   â”œâ”€â”€ tasks/
â”‚   â”‚   â””â”€â”€ main.yml
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â””â”€â”€ index.html
â”‚   â”œâ”€â”€ vars/
â”‚   â”‚   â””â”€â”€ main.yml  # This will reference vars.yaml (the file you mentioned)
â”‚   â”œâ”€â”€ defaults/
â”‚   â”‚   â””â”€â”€ main.yml  # Default values for any variables
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â””â”€â”€ main.yml  # Handlers for tasks like restarting services
â”‚   â””â”€â”€ meta/
â”‚       â””â”€â”€ main.yml


 Step-by-Step Conversion

1. Create the role directory structure.
2. Move the tasks to the `tasks/main.yml` file.
3. Move the `index.html` template to the `templates/` directory.
4. Move the `vars.yaml` to the `vars/main.yml` file (if necessary).
5. Define the handler to restart the HTTP service in `handlers/main.yml`.

---

 Role Files

# 1. `roles/apache/tasks/main.yml`

yaml
---
# tasks/main.yml

- name: Install Apache HTTP Server
  yum:
    name: "{{ apache_package_name }}"
    state: present
  tags: install

- name: Ensure httpd is started and enabled
  service:
    name: httpd
    state: started
    enabled: true
  tags: configure

- name: Copy custom index.html to the web root
  template:
    src: index.html  # Path to your local index.html template
    dest: /var/www/html/index.html  # Destination on the target server
  notify:
    - restarting httpd
  tags: deploy


# 2. `roles/apache/templates/index.html`

Place your `index.html` file in this directory. This will be a template that Ansible can process, and if necessary,
you can include variables in this file (e.g., `{{ some_variable }}`) to make it dynamic.

Example `index.html` (with a simple template):


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Apache</title>
</head>
<body>
    <h1>Welcome to {{ apache_server_name }}!</h1>
    <p>This page is served by Apache on {{ ansible_hostname }}.</p>
</body>
</html>


# 3. `roles/apache/vars/main.yml`

Here, you can define the variables used by the playbook. For example, you can define the `apache_package_name` or 
any other variables that make the role more configurable.

yaml
----
# vars/main.yml

apache_package_name: httpd
apache_server_name: "My Apache Server"


# 4. `roles/apache/defaults/main.yml`

You can specify default values for variables here. These defaults can be overridden by the `vars/main.yml` or playbook.

yaml
---
# defaults/main.yml

apache_package_name: httpd
apache_server_name: "Default Apache Server"


# 5. `roles/apache/handlers/main.yml`

This file will contain the handler to restart the `httpd` service.

yaml
---
# handlers/main.yml

- name: restarting httpd
  service:
    name: httpd
    state: restarted


# 6. `roles/apache/meta/main.yml`

This file is for role metadata, including dependencies. For now, you can leave it empty unless you have dependencies.

yaml
----
# meta/main.yml

dependencies: []


 Using the Role in a Playbook

Now that the role is created, you can use it in your playbook by specifying the `vars.yaml` file and referencing the role.

# Main Playbook

yaml
---
- name: Install and configure httpd on all servers
  hosts: all  
  gather_facts: no  # set to yes so we can use ansible facts like ansible_hostname
  become: true  
  vars_files:
    - vars.yaml  # This file will be referenced in the playbook
  roles:
    - httpd


# `vars.yaml` File (if it's separate from `vars/main.yml`)

If you are using an external `vars.yaml` file, it can be placed alongside the playbook:

yaml
---
# vars.yaml

apache_server_name: "Custom Apache Server"


 Final Notes:

- Modularity: The role is now modular and can be reused across multiple playbooks.
- Customizability: You can customize the Apache server name, package name, and other variables by modifying `vars/main.yml` or the `vars.yaml` file.
- Template: The `index.html` template allows for dynamic content generation based on Ansible facts or variables. For example, `{{ ansible_hostname }}` 
  can be used to display the hostâ€™s name in the web page.










Ansible vault
==============

Ansible Vault is a feature that allows you to encrypt sensitive data such as passwords, SSH keys, and API tokens inside Ansible playbooks or inventory files. 
This ensures that sensitive information is securely stored and only accessible with a password.

---

 Step 1: Create an Encrypted File
-------
First, create a vault-encrypted file to store sensitive data.


ansible-vault create secret.yml


- Enter a vault password (remember this, youâ€™ll need it later).
- A text editor opens. Add the following sensitive data:


db_password: "SuperSecretPassword123"
api_key: "abcdef1234567890"





Step 2: View the Encrypted File
-------

Now, check how Ansible Vault has encrypted your file:


cat secret.yml


âœ… Expected Output:  
The file should appear fully encrypted, something like this:


$ANSIBLE_VAULT;1.1;AES256
6162636465663738393031323334353637383930...


---

Step 3: Edit the Encrypted File
-------

To modify the vault-encrypted file, use:


ansible-vault edit secret.yml


ğŸ”¹ Enter the vault password.  
ğŸ”¹ Make changes to the file (e.g., update the password).  
ğŸ”¹ Save and exit.

---

Step 4: Decrypt the File (Optional)
--------

If you need to remove encryption and see plain text:


ansible-vault decrypt secret.yml


Now, check the file:


cat secret.yml


âœ… It should now be readable as normal YAML.

---

Step 5: Re-Encrypt the File
-------

To re-encrypt a decrypted file:


ansible-vault encrypt secret.yml


Enter the vault password, and it will be encrypted again.

---

Step 6: Use Vault in a Playbook
-------

Letâ€™s create a playbook that uses the vault-encrypted variables.

ğŸ”¹ Create `playbook.yml`:

yaml
---
- name: Test Ansible Vault
  hosts: all
  vars_files:
    - secret.yaml
  tasks:
    - name: Print sensitive variables
      debug:
        msg: "The database password is {{ db_password }}"


Run the playbook with Vault:


ansible-playbook vaulttest.yaml --ask-vault-pass


âœ… Expected Output:
json
TASK [Print sensitive variables] 
ok: [localhost] => {
    "msg": "The database password is SuperSecretPassword123"
}


---

Step 7: Use Vault with a Password File
-------

Instead of manually entering the vault password, store it in a file:

1ï¸âƒ£ Create a password file:


echo "kkdevops" > vault-password.txt
chmod 600 vault-password.txt


2ï¸âƒ£ Run the playbook using the password file:


ansible-playbook vaulttest.yaml --vault-password-file password.txt


âœ… No need to type the password manually!

---

 ğŸ¯ Summary
- `ansible-vault create secret.yml` â†’ Create encrypted file  
- `ansible-vault view secret.yml` â†’ View encrypted content  
- `ansible-vault edit secret.yml` â†’ Modify encrypted content  
- `ansible-vault decrypt secret.yml` â†’ Remove encryption  
- `ansible-vault encrypt secret.yml` â†’ Re-encrypt file  
- Use `--ask-vault-pass` or `--vault-password-file` for automation  

---

# ğŸ”¥ Bonus: Encrypt an Entire Playbook
Instead of encrypting just variables, encrypt an entire playbook:

bash
ansible-vault encrypt playbook.yml


Run it:

bash
ansible-playbook playbook.yml --ask-vault-pass





NOTE : if you want to reset the password ,pls use below command

ansible-vault rekey abc.yaml



âš ï¸ Important
âŒ There is NO way to recover a lost vault password.
âœ… Always keep a backup of unencrypted files before encrypting.





ğŸ“ Introduction to Ansible Dynamic Inventory
==============================================
Ansible Inventory is the list of hosts (servers) that Ansible manages. By default, Ansible uses a static inventory file (e.g., inventory.ini), 
where hosts and groups are manually defined.

However, in cloud environments like AWS, servers are dynamicâ€”they are created and terminated frequently. Manually updating inventory files 
becomes inefficient and error-prone.

ğŸ”¹ What is Ansible Dynamic Inventory?
=====================================

Ansible Dynamic Inventory automatically retrieves real-time information about cloud instances, virtual machines, or containers from external sources 
like AWS, Azure, GCP, or Kubernetes.

Instead of maintaining a static hosts file, Ansible queries the cloud providerâ€™s API and dynamically builds the inventory.

ğŸ’¡ Why Use Dynamic Inventory?
âœ… No Manual Updates â€“ Automatically detects new servers and removes old ones.
âœ… Works with Cloud â€“ Fetches real-time AWS EC2 instances, Azure VMs, or Kubernetes pods.
âœ… Uses Tags and Filters â€“ Group hosts based on tags (e.g., all web servers, db servers).
âœ… Efficient and Scalable â€“ Ideal for large-scale cloud environments.




---

 **ğŸ“Œ Prerequisites**
1. **AWS Account** with proper IAM permissions.
2. **Ansible installed** on a control node (Linux/macOS).
3. **Python and Boto3** installed on the control node.
4. **AWS CLI installed** and configured with access keys.

---

 **1ï¸âƒ£ Install Required Dependencies**
Ensure you have the required Python packages installed:

sudo yum update -y
sudo yum install python3 -y
sudo yum install python3-pip -y

pip3 --version


sudo pip install boto3 botocore

#pip install ansible


---

 **2ï¸âƒ£ Configure AWS Credentials**
Ansible needs access to AWS. You can set up your credentials using:

AWS cli
-------
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
sudo yum install unzip -y
unzip awscliv2.zip
sudo ./aws/install
aws --version






aws configure



[default]
aws_access_key_id = YOUR_ACCESS_KEY
aws_secret_access_key = YOUR_SECRET_KEY
region = ap-south-1



---

 **3ï¸âƒ£ Enable Ansible AWS Collection**
Ensure the AWS collection is installed:


ansible-galaxy collection install amazon.aws


---

 **4ï¸âƒ£ Create a Dynamic Inventory File**
Ansible provides a **dynamic inventory plugin** for AWS.

ğŸ“Œ Create an inventory configuration file:

mkdir -p ~/ansible/inventory
cd ~/ansible/inventory


Create a file `aws_ec2.yml`:

plugin: amazon.aws.aws_ec2
regions:
  - ap-south-1
filters:
  instance-state-name: running
keyed_groups:
  - key: tags.Name
    prefix: "tag_"
compose:
  ansible_host: public_ip_address


---

 **5ï¸âƒ£ Verify the Dynamic Inventory**
Run the following command to ensure Ansible can fetch instances:


ansible-inventory -i aws_ec2.yml --list



If everything is set up correctly, you should see a JSON output of AWS EC2 instances.

---

 **6ï¸âƒ£ Run Ansible Commands on AWS Instances**
 **ğŸ“Œ Example: Ping all AWS EC2 Instances**

ansible all -i aws_ec2.yml -m ping -u ec2-user --private-key /home/ec2-user/kkdevopsbl3b2.pem


ansible tag__Hosts -i aws_ec2.yml -m ping -u ec2-user --private-key /home/ec2-user/kkdevopsbl3b2.pem



 **ğŸ“Œ Example: Run a Command on all EC2 instances**


 ansible all -i aws_ec2.yml -m shell -a "uptime" -u ec2-user --private-key /home/ec2-user/kkdevopsbl3b2.pem


---

 **7ï¸âƒ£ Create & Run a Playbook**
ğŸ“Œ **Create a playbook** `install_apache.yml`:
yaml
- name: Install Apache on AWS EC2
  hosts: tag_WebServers
  become: yes
  tasks:
    - name: Install Apache
      ansible.builtin.yum:
        name: httpd
        state: present

    - name: Start Apache Service
      ansible.builtin.service:
        name: httpd
        state: started
        enabled: yes


ğŸ“Œ **Run the playbook**:

ansible-playbook -i aws_ec2.yml gitInstall.yaml -u ec2-user --private-key /home/ec2-user/kkdevopsbl3b2.pem



---

 **ğŸ“Œ Summary**
1. Install `boto3` and `ansible-galaxy collection install amazon.aws`
2. Set up AWS credentials.
3. Create `aws_ec2.yml` for dynamic inventory.
4. Test with `ansible-inventory --list`
5. Run Ansible commands on AWS EC2 instances.
6. Deploy Playbooks dynamically.

This should be a **practical and engaging session** for your students. Let me know if you need any modifications or additional examples! ğŸš€
